//go:build ignore

// internal/tables/generate_iq_table.go
// Generator for inverse quantization table.
// Extracts exact values from FAAD2's iq_table.h to ensure bit-exact matching.
// Run with: go run generate_iq_table.go
package main

import (
	"bufio"
	"fmt"
	"os"
	"regexp"
	"strconv"
	"strings"
	"time"
)

const (
	iqTableSize    = 8192
	outputFile     = "iq_table_data.go"
	faad2TableFile = "/home/laurent/dev/faad2/libfaad/iq_table.h"
)

func main() {
	// Read values from FAAD2's iq_table.h
	values, err := extractFAAD2Values(faad2TableFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "error extracting FAAD2 values: %v\n", err)
		os.Exit(1)
	}

	if len(values) != iqTableSize {
		fmt.Fprintf(os.Stderr, "expected %d values, got %d\n", iqTableSize, len(values))
		os.Exit(1)
	}

	// Create output file
	f, err := os.Create(outputFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "error creating file: %v\n", err)
		os.Exit(1)
	}
	defer f.Close()

	fmt.Fprintf(f, "// Code generated by generate_iq_table.go; DO NOT EDIT.\n")
	fmt.Fprintf(f, "// Generated at: %s\n", time.Now().Format(time.RFC3339))
	fmt.Fprintf(f, "//\n")
	fmt.Fprintf(f, "// Inverse quantization table: IQTable[i] = i^(4/3)\n")
	fmt.Fprintf(f, "// Values extracted directly from: %s\n", faad2TableFile)
	fmt.Fprintf(f, "// to ensure bit-exact matching with FAAD2.\n\n")
	fmt.Fprintf(f, "package tables\n\n")
	fmt.Fprintf(f, "func init() {\n")
	fmt.Fprintf(f, "\tiqTableData := [IQTableSize]float64{\n")

	for i := 0; i < iqTableSize; i++ {
		if i%4 == 0 {
			fmt.Fprintf(f, "\t\t")
		}
		fmt.Fprintf(f, "%s, ", values[i])
		if i%4 == 3 {
			fmt.Fprintf(f, "// %d-%d\n", i-3, i)
		}
	}
	fmt.Fprintf(f, "\t}\n")
	fmt.Fprintf(f, "\tcopy(IQTable[:], iqTableData[:])\n")
	fmt.Fprintf(f, "}\n")

	fmt.Printf("Generated %s with %d entries extracted from FAAD2\n", outputFile, iqTableSize)
}

// extractFAAD2Values reads the iq_table.h file and extracts all floating-point values
func extractFAAD2Values(filename string) ([]string, error) {
	file, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer file.Close()

	var values []string
	scanner := bufio.NewScanner(file)
	// Match floating-point numbers (including integers like 0, 1)
	numRegex := regexp.MustCompile(`^\s*(-?\d+\.?\d*(?:[eE][+-]?\d+)?),?\s*$`)

	inTable := false
	for scanner.Scan() {
		line := scanner.Text()

		// Detect start of table
		if strings.Contains(line, "iq_table[IQ_TABLE_SIZE]") {
			inTable = true
			continue
		}

		// Detect end of table
		if inTable && strings.Contains(line, "};") {
			break
		}

		if !inTable {
			continue
		}

		// Extract number from line
		if matches := numRegex.FindStringSubmatch(line); len(matches) > 1 {
			// Validate it's a valid number
			_, err := strconv.ParseFloat(matches[1], 64)
			if err == nil {
				values = append(values, matches[1])
			}
		}
	}

	if err := scanner.Err(); err != nil {
		return nil, err
	}

	return values, nil
}
