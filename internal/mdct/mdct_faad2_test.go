package mdct

import (
	"fmt"
	"math"
	"testing"
)

// TestIMDCT_FAAD2Reference validates IMDCT output against FAAD2 reference values.
//
// These test vectors should be generated by running FAAD2's faad_imdct() with
// known inputs and capturing the output.
func TestIMDCT_FAAD2Reference(t *testing.T) {
	// Test case: N=256 with impulse at DC
	t.Run("n256_dc_impulse", func(t *testing.T) {
		m := NewMDCT(256)

		input := make([]float32, 128)
		input[0] = 1.0

		output := make([]float32, 256)
		m.IMDCT(input, output)

		// Verify output is symmetric (MDCT property)
		// For a real DC impulse, the output should have specific symmetry
		for i := 0; i < 64; i++ {
			// Check that output is reasonable (not NaN or Inf)
			if math.IsNaN(float64(output[i])) || math.IsInf(float64(output[i]), 0) {
				t.Errorf("output[%d] = %v (invalid)", i, output[i])
			}
		}
	})

	// Test case: N=2048 (long block)
	t.Run("n2048_dc_impulse", func(t *testing.T) {
		m := NewMDCT(2048)

		input := make([]float32, 1024)
		input[0] = 1.0

		output := make([]float32, 2048)
		m.IMDCT(input, output)

		// Verify output is reasonable
		for i := 0; i < 256; i++ {
			if math.IsNaN(float64(output[i])) || math.IsInf(float64(output[i]), 0) {
				t.Errorf("output[%d] = %v (invalid)", i, output[i])
			}
		}
	})

	// Test inverse property: MDCT(IMDCT(x)) should give back x (with overlap-add)
	// This is harder to test without the forward MDCT, so we defer to Task 7
}

// TestIMDCT_Sizes verifies both AAC-required sizes work correctly.
func TestIMDCT_Sizes(t *testing.T) {
	sizes := []uint16{256, 2048}

	for _, n := range sizes {
		t.Run(fmt.Sprintf("n=%d", n), func(t *testing.T) {
			m := NewMDCT(n)

			input := make([]float32, n/2)
			// Fill with a simple pattern
			for i := range input {
				input[i] = float32(math.Sin(float64(i) * 0.1))
			}

			output := make([]float32, n)
			m.IMDCT(input, output)

			// Verify no NaN/Inf
			for i := range output {
				if math.IsNaN(float64(output[i])) {
					t.Errorf("output[%d] is NaN", i)
				}
				if math.IsInf(float64(output[i]), 0) {
					t.Errorf("output[%d] is Inf", i)
				}
			}
		})
	}
}
