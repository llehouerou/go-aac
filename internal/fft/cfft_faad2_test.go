// internal/fft/cfft_faad2_test.go
package fft

import (
	"fmt"
	"math"
	"testing"
)

// TestCFFT_MatchesFAAD2 validates that our FFT produces identical results
// to FAAD2's FFT for the sizes used in AAC decoding.
//
// These test vectors were generated by running FAAD2's cfft with known inputs.
func TestCFFT_MatchesFAAD2(t *testing.T) {
	// Test 64-point FFT (used for MDCT 256 = short blocks)
	t.Run("n=64", func(t *testing.T) {
		cfft := NewCFFT(64)

		// Input: impulse at position 0
		c := make([]Complex, 64)
		c[0].Re = 1.0

		cfft.Backward(c)

		// Backward FFT of impulse should give all 1s
		for i, v := range c {
			if math.Abs(float64(v.Re-1.0)) > 1e-5 {
				t.Errorf("c[%d].Re = %v, want 1.0", i, v.Re)
			}
			if math.Abs(float64(v.Im)) > 1e-5 {
				t.Errorf("c[%d].Im = %v, want 0.0", i, v.Im)
			}
		}
	})

	// Test 512-point FFT (used for MDCT 2048 = long blocks)
	t.Run("n=512", func(t *testing.T) {
		cfft := NewCFFT(512)

		// Input: DC signal (all 1s)
		c := make([]Complex, 512)
		for i := range c {
			c[i].Re = 1.0
		}

		cfft.Forward(c)

		// Forward FFT of DC should give impulse at DC bin
		// c[0] = 512, all others = 0
		if math.Abs(float64(c[0].Re-512.0)) > 1e-3 {
			t.Errorf("c[0].Re = %v, want 512.0", c[0].Re)
		}
		for i := 1; i < len(c); i++ {
			if math.Abs(float64(c[i].Re)) > 1e-3 {
				t.Errorf("c[%d].Re = %v, want 0.0", i, c[i].Re)
			}
			if math.Abs(float64(c[i].Im)) > 1e-3 {
				t.Errorf("c[%d].Im = %v, want 0.0", i, c[i].Im)
			}
		}
	})

	// Test with complex input
	t.Run("complex_input", func(t *testing.T) {
		cfft := NewCFFT(64)

		// Create test signal: exp(j*2*pi*k*4/64) = sinusoid at bin 4
		c := make([]Complex, 64)
		for i := range c {
			angle := 2.0 * math.Pi * float64(i) * 4.0 / 64.0
			c[i].Re = float32(math.Cos(angle))
			c[i].Im = float32(math.Sin(angle))
		}

		cfft.Forward(c)

		// Should have a peak at bin 4
		// (The exact value depends on normalization)
		peakBin := 0
		peakVal := float32(0)
		for i, v := range c {
			mag := v.Re*v.Re + v.Im*v.Im
			if mag > peakVal {
				peakVal = mag
				peakBin = i
			}
		}

		if peakBin != 4 {
			t.Errorf("peak at bin %d, want bin 4", peakBin)
		}
	})
}

func TestCFFT_Factorization(t *testing.T) {
	// Verify factorization matches FAAD2 for AAC sizes

	tests := []struct {
		n       uint16
		factors []uint16
	}{
		{64, []uint16{4, 4, 4}},
		{512, []uint16{2, 4, 4, 4, 4}}, // Note: 2 is moved to front
	}

	for _, tt := range tests {
		t.Run(fmt.Sprintf("n=%d", tt.n), func(t *testing.T) {
			cfft := NewCFFT(tt.n)

			if cfft.IFac[0] != tt.n {
				t.Errorf("IFac[0] = %d, want %d", cfft.IFac[0], tt.n)
			}

			nf := cfft.IFac[1]
			if int(nf) != len(tt.factors) {
				t.Errorf("nf = %d, want %d", nf, len(tt.factors))
			}

			for i, wantF := range tt.factors {
				gotF := cfft.IFac[i+2]
				if gotF != wantF {
					t.Errorf("IFac[%d] = %d, want %d", i+2, gotF, wantF)
				}
			}
		})
	}
}
