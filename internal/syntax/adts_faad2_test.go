package syntax

import (
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"testing"

	"github.com/llehouerou/go-aac/internal/bits"
)

// TestParseADTS_FAAD2Reference compares parsed ADTS headers against
// FAAD2 reference data generated by scripts/faad2_debug.
func TestParseADTS_FAAD2Reference(t *testing.T) {
	testFile := "../../testdata/sine1k.aac"
	if _, err := os.Stat(testFile); os.IsNotExist(err) {
		t.Skip("Test file not available")
	}

	// Generate reference data using faad2_debug
	refDir := t.TempDir()

	// Check if faad2_debug exists
	faad2Debug := "../../scripts/faad2_debug"
	if _, err := os.Stat(faad2Debug); os.IsNotExist(err) {
		t.Skip("faad2_debug not built - run 'make' in scripts/")
	}

	cmd := exec.Command(faad2Debug, testFile, refDir, "5")
	output, err := cmd.CombinedOutput()
	if err != nil {
		t.Skipf("faad2_debug failed: %v\n%s", err, output)
	}

	// Read test file
	data, err := os.ReadFile(testFile)
	if err != nil {
		t.Fatalf("Failed to read test file: %v", err)
	}

	// Parse frames and compare
	offset := 0
	for frame := range 5 {
		refPath := filepath.Join(refDir, fmt.Sprintf("frame_%04d_adts.bin", frame))

		refData, err := os.ReadFile(refPath)
		if err != nil {
			t.Logf("Frame %d: no reference data (end of file?)", frame)
			break
		}
		if len(refData) != 16 {
			t.Fatalf("Frame %d: invalid reference size %d", frame, len(refData))
		}

		// Parse with Go
		r := bits.NewReader(data[offset:])
		h, err := ParseADTS(r)
		if err != nil {
			t.Fatalf("Frame %d: ParseADTS failed: %v", frame, err)
		}

		// Compare against reference (see faad2_debug.c dump_adts_header format)
		// buf[0-1]: syncword (big-endian)
		// buf[2]: id
		// buf[3]: layer
		// buf[4]: protection_absent
		// buf[5]: profile
		// buf[6]: sf_index
		// buf[7]: private_bit
		// buf[8]: channel_config
		// buf[9]: original
		// buf[10]: home
		// buf[11-12]: frame_length (big-endian)
		// buf[13-14]: buffer_fullness (big-endian)
		// buf[15]: num_raw_blocks

		refSyncword := uint16(refData[0])<<8 | uint16(refData[1])
		if h.Syncword != refSyncword {
			t.Errorf("Frame %d: Syncword = 0x%X, ref = 0x%X",
				frame, h.Syncword, refSyncword)
		}

		if h.ID != refData[2] {
			t.Errorf("Frame %d: ID = %d, ref = %d", frame, h.ID, refData[2])
		}

		if h.Layer != refData[3] {
			t.Errorf("Frame %d: Layer = %d, ref = %d", frame, h.Layer, refData[3])
		}

		refProtAbsent := refData[4] == 1
		if h.ProtectionAbsent != refProtAbsent {
			t.Errorf("Frame %d: ProtectionAbsent = %v, ref = %v",
				frame, h.ProtectionAbsent, refProtAbsent)
		}

		if h.Profile != refData[5] {
			t.Errorf("Frame %d: Profile = %d, ref = %d", frame, h.Profile, refData[5])
		}

		if h.SFIndex != refData[6] {
			t.Errorf("Frame %d: SFIndex = %d, ref = %d", frame, h.SFIndex, refData[6])
		}

		if h.ChannelConfiguration != refData[8] {
			t.Errorf("Frame %d: ChannelConfig = %d, ref = %d",
				frame, h.ChannelConfiguration, refData[8])
		}

		refFrameLen := uint16(refData[11])<<8 | uint16(refData[12])
		if h.AACFrameLength != refFrameLen {
			t.Errorf("Frame %d: FrameLength = %d, ref = %d",
				frame, h.AACFrameLength, refFrameLen)
		}

		refBufFull := uint16(refData[13])<<8 | uint16(refData[14])
		if h.ADTSBufferFullness != refBufFull {
			t.Errorf("Frame %d: BufferFullness = %d, ref = %d",
				frame, h.ADTSBufferFullness, refBufFull)
		}

		if h.NoRawDataBlocksInFrame != refData[15] {
			t.Errorf("Frame %d: NumRawBlocks = %d, ref = %d",
				frame, h.NoRawDataBlocksInFrame, refData[15])
		}

		t.Logf("Frame %d: PASS (length=%d, channels=%d)",
			frame, h.AACFrameLength, h.ChannelConfiguration)

		offset += int(h.AACFrameLength)
	}
}
