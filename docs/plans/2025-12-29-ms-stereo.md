# M/S Stereo Decoding Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Implement Mid/Side stereo decoding for AAC channel pair elements (CPE)

**Architecture:** M/S stereo stores the sum (Mid) and difference (Side) of left and right channels. Decoding converts back to L/R: `L = M + S`, `R = M - S`. The transform is applied per scalefactor band when the ms_used mask is set, but skipped for intensity stereo and noise (PNS) bands.

**Tech Stack:** Pure Go, no external dependencies. Uses existing `syntax.ICStream` and `huffman.Codebook` types.

---

## Reference

**FAAD2 Source:** `~/dev/faad2/libfaad/ms.c` (77 lines), `ms.h` (44 lines)

**Key algorithm from ms.c:39-77:**
```c
void ms_decode(ic_stream *ics, ic_stream *icsr, real_t *l_spec, real_t *r_spec,
               uint16_t frame_len)
{
    // For each window group, for each window, for each SFB:
    // If M/S is enabled AND not intensity stereo AND not noise:
    //   tmp = L - R
    //   L = L + R
    //   R = tmp
}
```

---

## Task 1: Add IsIntensityICS and IsNoiseICS Helper Functions

The existing `IsIntensity` and `IsNoise` functions take a codebook directly. We need versions that look up the codebook from an ICS by group/sfb indices (matching FAAD2's inline functions).

**Files:**
- Modify: `internal/spectrum/helpers.go`
- Modify: `internal/spectrum/helpers_test.go`

**Step 1: Write the failing tests**

Add to `internal/spectrum/helpers_test.go`:

```go
func TestIsIntensityICS(t *testing.T) {
	ics := &syntax.ICStream{}

	// Test normal codebook
	ics.SFBCB[0][0] = uint8(huffman.EscHCB)
	if got := IsIntensityICS(ics, 0, 0); got != 0 {
		t.Errorf("IsIntensityICS with EscHCB = %d, want 0", got)
	}

	// Test intensity HCB (in-phase)
	ics.SFBCB[1][2] = uint8(huffman.IntensityHCB)
	if got := IsIntensityICS(ics, 1, 2); got != 1 {
		t.Errorf("IsIntensityICS with IntensityHCB = %d, want 1", got)
	}

	// Test intensity HCB2 (out-of-phase)
	ics.SFBCB[2][3] = uint8(huffman.IntensityHCB2)
	if got := IsIntensityICS(ics, 2, 3); got != -1 {
		t.Errorf("IsIntensityICS with IntensityHCB2 = %d, want -1", got)
	}
}

func TestIsNoiseICS(t *testing.T) {
	ics := &syntax.ICStream{}

	// Test normal codebook
	ics.SFBCB[0][0] = uint8(huffman.EscHCB)
	if IsNoiseICS(ics, 0, 0) {
		t.Error("IsNoiseICS with EscHCB = true, want false")
	}

	// Test noise codebook
	ics.SFBCB[1][2] = uint8(huffman.NoiseHCB)
	if !IsNoiseICS(ics, 1, 2) {
		t.Error("IsNoiseICS with NoiseHCB = false, want true")
	}
}
```

**Step 2: Run tests to verify they fail**

Run: `make test PKG=./internal/spectrum`
Expected: FAIL with "undefined: IsIntensityICS" and "undefined: IsNoiseICS"

**Step 3: Write minimal implementation**

Add to `internal/spectrum/helpers.go`:

```go
// IsIntensityICS returns the intensity stereo direction for a scalefactor band.
// Returns 1 for in-phase (INTENSITY_HCB), -1 for out-of-phase (INTENSITY_HCB2), 0 otherwise.
//
// Ported from: is_intensity() in ~/dev/faad2/libfaad/is.h:43-54
func IsIntensityICS(ics *syntax.ICStream, group, sfb uint8) int8 {
	return IsIntensity(huffman.Codebook(ics.SFBCB[group][sfb]))
}

// IsNoiseICS returns true if the scalefactor band uses noise (PNS) coding.
//
// Ported from: is_noise() in ~/dev/faad2/libfaad/pns.h:47-52
func IsNoiseICS(ics *syntax.ICStream, group, sfb uint8) bool {
	return IsNoise(huffman.Codebook(ics.SFBCB[group][sfb]))
}
```

**Step 4: Run tests to verify they pass**

Run: `make test PKG=./internal/spectrum`
Expected: PASS

**Step 5: Commit**

```bash
git add internal/spectrum/helpers.go internal/spectrum/helpers_test.go
git commit -m "$(cat <<'EOF'
feat(spectrum): add IsIntensityICS and IsNoiseICS helpers

Add ICS-based versions of intensity/noise detection that look up
the codebook from the ICS structure by group and SFB indices.

 Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
EOF
)"
```

---

## Task 2: Create ms.go with MSDecode Function Signature and Config

**Files:**
- Create: `internal/spectrum/ms.go`
- Create: `internal/spectrum/ms_test.go`

**Step 1: Write the failing test for basic M/S disabled case**

Create `internal/spectrum/ms_test.go`:

```go
package spectrum

import (
	"testing"

	"github.com/llehouerou/go-aac/internal/syntax"
)

func TestMSDecode_MSMaskNotPresent(t *testing.T) {
	// When ms_mask_present = 0, M/S decoding is disabled
	icsL := &syntax.ICStream{
		NumWindowGroups: 1,
		MaxSFB:          1,
		MSMaskPresent:   0, // No M/S
	}
	icsL.WindowGroupLength[0] = 1
	icsL.SWBOffset[0] = 0
	icsL.SWBOffset[1] = 4
	icsL.SWBOffsetMax = 1024

	icsR := &syntax.ICStream{
		NumWindowGroups: 1,
		MaxSFB:          1,
	}
	icsR.WindowGroupLength[0] = 1
	icsR.SWBOffset[0] = 0
	icsR.SWBOffset[1] = 4

	// Input: Left = [1,2,3,4], Right = [5,6,7,8]
	lSpec := []float64{1.0, 2.0, 3.0, 4.0}
	rSpec := []float64{5.0, 6.0, 7.0, 8.0}

	cfg := &MSDecodeConfig{
		ICSL:        icsL,
		ICSR:        icsR,
		FrameLength: 1024,
	}

	MSDecode(lSpec, rSpec, cfg)

	// Should be unchanged
	expectedL := []float64{1.0, 2.0, 3.0, 4.0}
	expectedR := []float64{5.0, 6.0, 7.0, 8.0}

	for i := range lSpec {
		if lSpec[i] != expectedL[i] {
			t.Errorf("lSpec[%d] = %v, want %v", i, lSpec[i], expectedL[i])
		}
		if rSpec[i] != expectedR[i] {
			t.Errorf("rSpec[%d] = %v, want %v", i, rSpec[i], expectedR[i])
		}
	}
}
```

**Step 2: Run test to verify it fails**

Run: `make test PKG=./internal/spectrum`
Expected: FAIL with "undefined: MSDecodeConfig" or "undefined: MSDecode"

**Step 3: Write minimal implementation**

Create `internal/spectrum/ms.go`:

```go
package spectrum

import "github.com/llehouerou/go-aac/internal/syntax"

// MSDecodeConfig holds configuration for M/S stereo decoding.
type MSDecodeConfig struct {
	// ICSL is the left channel's individual channel stream (contains ms_mask_present, ms_used)
	ICSL *syntax.ICStream

	// ICSR is the right channel's individual channel stream
	ICSR *syntax.ICStream

	// FrameLength is the frame length (typically 1024 or 960)
	FrameLength uint16
}

// MSDecode applies Mid/Side stereo decoding to spectral coefficients in-place.
// Converts M/S encoded bands back to L/R: L = M + S, R = M - S
//
// M/S decoding is skipped for:
// - Bands where ms_mask_present = 0
// - Intensity stereo bands (handled by is_decode)
// - Noise bands (handled by pns_decode)
//
// Ported from: ms_decode() in ~/dev/faad2/libfaad/ms.c:39-77
func MSDecode(lSpec, rSpec []float64, cfg *MSDecodeConfig) {
	icsL := cfg.ICSL

	// M/S not present
	if icsL.MSMaskPresent < 1 {
		return
	}
}
```

**Step 4: Run test to verify it passes**

Run: `make test PKG=./internal/spectrum`
Expected: PASS

**Step 5: Commit**

```bash
git add internal/spectrum/ms.go internal/spectrum/ms_test.go
git commit -m "$(cat <<'EOF'
feat(spectrum): add MSDecode stub with MSDecodeConfig

Add the M/S stereo decoder function signature and config struct.
Initial implementation handles the ms_mask_present=0 case (disabled).

 Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
EOF
)"
```

---

## Task 3: Implement M/S Decoding for ms_mask_present=2 (All Bands)

**Files:**
- Modify: `internal/spectrum/ms.go`
- Modify: `internal/spectrum/ms_test.go`

**Step 1: Write the failing test**

Add to `internal/spectrum/ms_test.go`:

```go
func TestMSDecode_MSMaskAll_LongBlock(t *testing.T) {
	// ms_mask_present = 2 means M/S applies to ALL bands
	icsL := &syntax.ICStream{
		NumWindowGroups: 1,
		MaxSFB:          1,
		NumSWB:          1,
		MSMaskPresent:   2, // All bands use M/S
		WindowSequence:  syntax.OnlyLongSequence,
	}
	icsL.WindowGroupLength[0] = 1
	icsL.SWBOffset[0] = 0
	icsL.SWBOffset[1] = 4
	icsL.SWBOffsetMax = 1024
	icsL.SFBCB[0][0] = 1 // Normal codebook (not intensity/noise)

	icsR := &syntax.ICStream{
		NumWindowGroups: 1,
		MaxSFB:          1,
		NumSWB:          1,
		WindowSequence:  syntax.OnlyLongSequence,
	}
	icsR.WindowGroupLength[0] = 1
	icsR.SWBOffset[0] = 0
	icsR.SWBOffset[1] = 4
	icsR.SFBCB[0][0] = 1

	// Input: M = [10, 20, 30, 40], S = [2, 4, 6, 8]
	// After M/S: L = M + S = [12, 24, 36, 48]
	//            R = M - S = [8, 16, 24, 32]
	lSpec := []float64{10.0, 20.0, 30.0, 40.0}
	rSpec := []float64{2.0, 4.0, 6.0, 8.0}

	cfg := &MSDecodeConfig{
		ICSL:        icsL,
		ICSR:        icsR,
		FrameLength: 1024,
	}

	MSDecode(lSpec, rSpec, cfg)

	expectedL := []float64{12.0, 24.0, 36.0, 48.0}
	expectedR := []float64{8.0, 16.0, 24.0, 32.0}

	for i := range lSpec {
		if lSpec[i] != expectedL[i] {
			t.Errorf("lSpec[%d] = %v, want %v", i, lSpec[i], expectedL[i])
		}
		if rSpec[i] != expectedR[i] {
			t.Errorf("rSpec[%d] = %v, want %v", i, rSpec[i], expectedR[i])
		}
	}
}
```

**Step 2: Run test to verify it fails**

Run: `make test PKG=./internal/spectrum`
Expected: FAIL with values unchanged

**Step 3: Implement M/S transform**

Update `internal/spectrum/ms.go` to add the core logic:

```go
package spectrum

import "github.com/llehouerou/go-aac/internal/syntax"

// MSDecodeConfig holds configuration for M/S stereo decoding.
type MSDecodeConfig struct {
	// ICSL is the left channel's individual channel stream (contains ms_mask_present, ms_used)
	ICSL *syntax.ICStream

	// ICSR is the right channel's individual channel stream
	ICSR *syntax.ICStream

	// FrameLength is the frame length (typically 1024 or 960)
	FrameLength uint16
}

// MSDecode applies Mid/Side stereo decoding to spectral coefficients in-place.
// Converts M/S encoded bands back to L/R: L = M + S, R = M - S
//
// M/S decoding is skipped for:
// - Bands where ms_mask_present = 0
// - Intensity stereo bands (handled by is_decode)
// - Noise bands (handled by pns_decode)
//
// Ported from: ms_decode() in ~/dev/faad2/libfaad/ms.c:39-77
func MSDecode(lSpec, rSpec []float64, cfg *MSDecodeConfig) {
	icsL := cfg.ICSL
	icsR := cfg.ICSR

	// M/S not present
	if icsL.MSMaskPresent < 1 {
		return
	}

	nshort := cfg.FrameLength / 8
	group := uint16(0)

	for g := uint8(0); g < icsL.NumWindowGroups; g++ {
		for b := uint8(0); b < icsL.WindowGroupLength[g]; b++ {
			for sfb := uint8(0); sfb < icsL.MaxSFB; sfb++ {
				// Apply M/S if:
				// - ms_used[g][sfb] is set OR ms_mask_present == 2 (all bands)
				// - AND NOT intensity stereo in right channel
				// - AND NOT noise in left channel
				msEnabled := icsL.MSUsed[g][sfb] != 0 || icsL.MSMaskPresent == 2
				if msEnabled && IsIntensityICS(icsR, g, sfb) == 0 && !IsNoiseICS(icsL, g, sfb) {
					// Calculate SFB bounds, clamped to swb_offset_max
					start := icsL.SWBOffset[sfb]
					end := icsL.SWBOffset[sfb+1]
					if end > icsL.SWBOffsetMax {
						end = icsL.SWBOffsetMax
					}

					for i := start; i < end; i++ {
						k := group*nshort + i
						tmp := lSpec[k] - rSpec[k]
						lSpec[k] = lSpec[k] + rSpec[k]
						rSpec[k] = tmp
					}
				}
			}
			group++
		}
	}
}
```

**Step 4: Run test to verify it passes**

Run: `make test PKG=./internal/spectrum`
Expected: PASS

**Step 5: Commit**

```bash
git add internal/spectrum/ms.go internal/spectrum/ms_test.go
git commit -m "$(cat <<'EOF'
feat(spectrum): implement M/S stereo decoding core logic

Implement the M/S transform: L = M + S, R = M - S
Handles ms_mask_present=2 (all bands) case with proper bounds clamping.
Skips intensity stereo and noise bands as per spec.

 Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
EOF
)"
```

---

## Task 4: Add Test for ms_mask_present=1 (Per-Band Mask)

**Files:**
- Modify: `internal/spectrum/ms_test.go`

**Step 1: Write the test**

Add to `internal/spectrum/ms_test.go`:

```go
func TestMSDecode_MSMaskPerBand(t *testing.T) {
	// ms_mask_present = 1 means per-band M/S mask
	icsL := &syntax.ICStream{
		NumWindowGroups: 1,
		MaxSFB:          3,
		NumSWB:          3,
		MSMaskPresent:   1, // Per-band mask
		WindowSequence:  syntax.OnlyLongSequence,
	}
	icsL.WindowGroupLength[0] = 1
	icsL.SWBOffset[0] = 0
	icsL.SWBOffset[1] = 4
	icsL.SWBOffset[2] = 8
	icsL.SWBOffset[3] = 12
	icsL.SWBOffsetMax = 1024
	icsL.SFBCB[0][0] = 1
	icsL.SFBCB[0][1] = 1
	icsL.SFBCB[0][2] = 1

	// SFB 0: M/S enabled
	// SFB 1: M/S disabled
	// SFB 2: M/S enabled
	icsL.MSUsed[0][0] = 1
	icsL.MSUsed[0][1] = 0
	icsL.MSUsed[0][2] = 1

	icsR := &syntax.ICStream{
		NumWindowGroups: 1,
		MaxSFB:          3,
		NumSWB:          3,
		WindowSequence:  syntax.OnlyLongSequence,
	}
	icsR.WindowGroupLength[0] = 1
	icsR.SWBOffset[0] = 0
	icsR.SWBOffset[1] = 4
	icsR.SWBOffset[2] = 8
	icsR.SWBOffset[3] = 12
	icsR.SFBCB[0][0] = 1
	icsR.SFBCB[0][1] = 1
	icsR.SFBCB[0][2] = 1

	// Input: all M=10, S=2
	lSpec := make([]float64, 12)
	rSpec := make([]float64, 12)
	for i := 0; i < 12; i++ {
		lSpec[i] = 10.0
		rSpec[i] = 2.0
	}

	cfg := &MSDecodeConfig{
		ICSL:        icsL,
		ICSR:        icsR,
		FrameLength: 1024,
	}

	MSDecode(lSpec, rSpec, cfg)

	// SFB 0 (indices 0-3): M/S applied -> L=12, R=8
	for i := 0; i < 4; i++ {
		if lSpec[i] != 12.0 {
			t.Errorf("lSpec[%d] = %v, want 12.0 (M/S applied)", i, lSpec[i])
		}
		if rSpec[i] != 8.0 {
			t.Errorf("rSpec[%d] = %v, want 8.0 (M/S applied)", i, rSpec[i])
		}
	}

	// SFB 1 (indices 4-7): M/S NOT applied -> unchanged
	for i := 4; i < 8; i++ {
		if lSpec[i] != 10.0 {
			t.Errorf("lSpec[%d] = %v, want 10.0 (unchanged)", i, lSpec[i])
		}
		if rSpec[i] != 2.0 {
			t.Errorf("rSpec[%d] = %v, want 2.0 (unchanged)", i, rSpec[i])
		}
	}

	// SFB 2 (indices 8-11): M/S applied -> L=12, R=8
	for i := 8; i < 12; i++ {
		if lSpec[i] != 12.0 {
			t.Errorf("lSpec[%d] = %v, want 12.0 (M/S applied)", i, lSpec[i])
		}
		if rSpec[i] != 8.0 {
			t.Errorf("rSpec[%d] = %v, want 8.0 (M/S applied)", i, rSpec[i])
		}
	}
}
```

**Step 2: Run test to verify it passes**

Run: `make test PKG=./internal/spectrum`
Expected: PASS (implementation already handles this case)

**Step 3: Commit**

```bash
git add internal/spectrum/ms_test.go
git commit -m "$(cat <<'EOF'
test(spectrum): add per-band M/S mask test

Test ms_mask_present=1 with selective per-band M/S enabling.
Verifies that only bands with ms_used[g][sfb]=1 are transformed.

 Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
EOF
)"
```

---

## Task 5: Add Test for Intensity Stereo Band Exclusion

**Files:**
- Modify: `internal/spectrum/ms_test.go`

**Step 1: Write the test**

Add to `internal/spectrum/ms_test.go`:

```go
func TestMSDecode_SkipsIntensityStereo(t *testing.T) {
	icsL := &syntax.ICStream{
		NumWindowGroups: 1,
		MaxSFB:          2,
		NumSWB:          2,
		MSMaskPresent:   2, // All bands use M/S
		WindowSequence:  syntax.OnlyLongSequence,
	}
	icsL.WindowGroupLength[0] = 1
	icsL.SWBOffset[0] = 0
	icsL.SWBOffset[1] = 4
	icsL.SWBOffset[2] = 8
	icsL.SWBOffsetMax = 1024
	icsL.SFBCB[0][0] = 1 // Normal
	icsL.SFBCB[0][1] = 1 // Normal (left)

	icsR := &syntax.ICStream{
		NumWindowGroups: 1,
		MaxSFB:          2,
		NumSWB:          2,
		WindowSequence:  syntax.OnlyLongSequence,
	}
	icsR.WindowGroupLength[0] = 1
	icsR.SWBOffset[0] = 0
	icsR.SWBOffset[1] = 4
	icsR.SWBOffset[2] = 8
	icsR.SFBCB[0][0] = 1                            // Normal
	icsR.SFBCB[0][1] = uint8(huffman.IntensityHCB) // Intensity stereo on right

	lSpec := make([]float64, 8)
	rSpec := make([]float64, 8)
	for i := 0; i < 8; i++ {
		lSpec[i] = 10.0
		rSpec[i] = 2.0
	}

	cfg := &MSDecodeConfig{
		ICSL:        icsL,
		ICSR:        icsR,
		FrameLength: 1024,
	}

	MSDecode(lSpec, rSpec, cfg)

	// SFB 0: M/S applied (no intensity) -> L=12, R=8
	for i := 0; i < 4; i++ {
		if lSpec[i] != 12.0 {
			t.Errorf("lSpec[%d] = %v, want 12.0", i, lSpec[i])
		}
		if rSpec[i] != 8.0 {
			t.Errorf("rSpec[%d] = %v, want 8.0", i, rSpec[i])
		}
	}

	// SFB 1: M/S skipped (intensity stereo) -> unchanged
	for i := 4; i < 8; i++ {
		if lSpec[i] != 10.0 {
			t.Errorf("lSpec[%d] = %v, want 10.0 (IS band, unchanged)", i, lSpec[i])
		}
		if rSpec[i] != 2.0 {
			t.Errorf("rSpec[%d] = %v, want 2.0 (IS band, unchanged)", i, rSpec[i])
		}
	}
}
```

Need to add import at top of test file:
```go
import (
	"testing"

	"github.com/llehouerou/go-aac/internal/huffman"
	"github.com/llehouerou/go-aac/internal/syntax"
)
```

**Step 2: Run test to verify it passes**

Run: `make test PKG=./internal/spectrum`
Expected: PASS

**Step 3: Commit**

```bash
git add internal/spectrum/ms_test.go
git commit -m "$(cat <<'EOF'
test(spectrum): add intensity stereo exclusion test for MSDecode

Verify that M/S decoding is skipped for bands where the right
channel uses intensity stereo codebooks (INTENSITY_HCB/HCB2).

 Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
EOF
)"
```

---

## Task 6: Add Test for Noise (PNS) Band Exclusion

**Files:**
- Modify: `internal/spectrum/ms_test.go`

**Step 1: Write the test**

Add to `internal/spectrum/ms_test.go`:

```go
func TestMSDecode_SkipsNoiseBands(t *testing.T) {
	icsL := &syntax.ICStream{
		NumWindowGroups: 1,
		MaxSFB:          2,
		NumSWB:          2,
		MSMaskPresent:   2, // All bands use M/S
		WindowSequence:  syntax.OnlyLongSequence,
	}
	icsL.WindowGroupLength[0] = 1
	icsL.SWBOffset[0] = 0
	icsL.SWBOffset[1] = 4
	icsL.SWBOffset[2] = 8
	icsL.SWBOffsetMax = 1024
	icsL.SFBCB[0][0] = 1                        // Normal
	icsL.SFBCB[0][1] = uint8(huffman.NoiseHCB) // Noise band

	icsR := &syntax.ICStream{
		NumWindowGroups: 1,
		MaxSFB:          2,
		NumSWB:          2,
		WindowSequence:  syntax.OnlyLongSequence,
	}
	icsR.WindowGroupLength[0] = 1
	icsR.SWBOffset[0] = 0
	icsR.SWBOffset[1] = 4
	icsR.SWBOffset[2] = 8
	icsR.SFBCB[0][0] = 1 // Normal
	icsR.SFBCB[0][1] = 1 // Normal

	lSpec := make([]float64, 8)
	rSpec := make([]float64, 8)
	for i := 0; i < 8; i++ {
		lSpec[i] = 10.0
		rSpec[i] = 2.0
	}

	cfg := &MSDecodeConfig{
		ICSL:        icsL,
		ICSR:        icsR,
		FrameLength: 1024,
	}

	MSDecode(lSpec, rSpec, cfg)

	// SFB 0: M/S applied (no noise) -> L=12, R=8
	for i := 0; i < 4; i++ {
		if lSpec[i] != 12.0 {
			t.Errorf("lSpec[%d] = %v, want 12.0", i, lSpec[i])
		}
		if rSpec[i] != 8.0 {
			t.Errorf("rSpec[%d] = %v, want 8.0", i, rSpec[i])
		}
	}

	// SFB 1: M/S skipped (noise band) -> unchanged
	for i := 4; i < 8; i++ {
		if lSpec[i] != 10.0 {
			t.Errorf("lSpec[%d] = %v, want 10.0 (noise band, unchanged)", i, lSpec[i])
		}
		if rSpec[i] != 2.0 {
			t.Errorf("rSpec[%d] = %v, want 2.0 (noise band, unchanged)", i, rSpec[i])
		}
	}
}
```

**Step 2: Run test to verify it passes**

Run: `make test PKG=./internal/spectrum`
Expected: PASS

**Step 3: Commit**

```bash
git add internal/spectrum/ms_test.go
git commit -m "$(cat <<'EOF'
test(spectrum): add noise band exclusion test for MSDecode

Verify that M/S decoding is skipped for bands where the left
channel uses the noise codebook (NOISE_HCB for PNS).

 Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
EOF
)"
```

---

## Task 7: Add Test for Short Blocks (Eight Short Sequence)

**Files:**
- Modify: `internal/spectrum/ms_test.go`

**Step 1: Write the test**

Add to `internal/spectrum/ms_test.go`:

```go
func TestMSDecode_ShortBlocks(t *testing.T) {
	// Test 8 short windows grouped into 2 groups of 4
	icsL := &syntax.ICStream{
		NumWindowGroups: 2,
		NumWindows:      8,
		MaxSFB:          1,
		NumSWB:          1,
		MSMaskPresent:   2,
		WindowSequence:  syntax.EightShortSequence,
	}
	icsL.WindowGroupLength[0] = 4 // First group: 4 windows
	icsL.WindowGroupLength[1] = 4 // Second group: 4 windows
	icsL.SWBOffset[0] = 0
	icsL.SWBOffset[1] = 4 // 4 coefficients per SFB per window
	icsL.SWBOffsetMax = 128
	icsL.SFBCB[0][0] = 1
	icsL.SFBCB[1][0] = 1

	icsR := &syntax.ICStream{
		NumWindowGroups: 2,
		NumWindows:      8,
		MaxSFB:          1,
		NumSWB:          1,
		WindowSequence:  syntax.EightShortSequence,
	}
	icsR.WindowGroupLength[0] = 4
	icsR.WindowGroupLength[1] = 4
	icsR.SWBOffset[0] = 0
	icsR.SWBOffset[1] = 4
	icsR.SFBCB[0][0] = 1
	icsR.SFBCB[1][0] = 1

	// FrameLength=1024, nshort=128
	// 8 windows * 4 coefficients = 32 total
	lSpec := make([]float64, 32)
	rSpec := make([]float64, 32)
	for i := 0; i < 32; i++ {
		lSpec[i] = 10.0
		rSpec[i] = 2.0
	}

	cfg := &MSDecodeConfig{
		ICSL:        icsL,
		ICSR:        icsR,
		FrameLength: 1024,
	}

	MSDecode(lSpec, rSpec, cfg)

	// All coefficients should be transformed: L=12, R=8
	for i := 0; i < 32; i++ {
		if lSpec[i] != 12.0 {
			t.Errorf("lSpec[%d] = %v, want 12.0", i, lSpec[i])
		}
		if rSpec[i] != 8.0 {
			t.Errorf("rSpec[%d] = %v, want 8.0", i, rSpec[i])
		}
	}
}
```

**Step 2: Run test to verify it passes**

Run: `make test PKG=./internal/spectrum`
Expected: PASS

**Step 3: Commit**

```bash
git add internal/spectrum/ms_test.go
git commit -m "$(cat <<'EOF'
test(spectrum): add short blocks test for MSDecode

Test M/S decoding with eight short windows in window groups.
Verifies correct coefficient indexing across multiple window groups.

 Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
EOF
)"
```

---

## Task 8: Add Test for SWBOffsetMax Clamping

**Files:**
- Modify: `internal/spectrum/ms_test.go`

**Step 1: Write the test**

Add to `internal/spectrum/ms_test.go`:

```go
func TestMSDecode_SWBOffsetMaxClamping(t *testing.T) {
	// Test that SFB bounds are clamped to SWBOffsetMax
	icsL := &syntax.ICStream{
		NumWindowGroups: 1,
		MaxSFB:          1,
		NumSWB:          1,
		MSMaskPresent:   2,
		WindowSequence:  syntax.OnlyLongSequence,
	}
	icsL.WindowGroupLength[0] = 1
	icsL.SWBOffset[0] = 0
	icsL.SWBOffset[1] = 100   // SFB would go to 100
	icsL.SWBOffsetMax = 50    // But max is 50
	icsL.SFBCB[0][0] = 1

	icsR := &syntax.ICStream{
		NumWindowGroups: 1,
		MaxSFB:          1,
		NumSWB:          1,
		WindowSequence:  syntax.OnlyLongSequence,
	}
	icsR.WindowGroupLength[0] = 1
	icsR.SWBOffset[0] = 0
	icsR.SWBOffset[1] = 100
	icsR.SFBCB[0][0] = 1

	// Only first 50 coefficients should be modified
	lSpec := make([]float64, 100)
	rSpec := make([]float64, 100)
	for i := 0; i < 100; i++ {
		lSpec[i] = 10.0
		rSpec[i] = 2.0
	}

	cfg := &MSDecodeConfig{
		ICSL:        icsL,
		ICSR:        icsR,
		FrameLength: 1024,
	}

	MSDecode(lSpec, rSpec, cfg)

	// First 50: M/S applied
	for i := 0; i < 50; i++ {
		if lSpec[i] != 12.0 {
			t.Errorf("lSpec[%d] = %v, want 12.0", i, lSpec[i])
		}
		if rSpec[i] != 8.0 {
			t.Errorf("rSpec[%d] = %v, want 8.0", i, rSpec[i])
		}
	}

	// 50-99: Unchanged (beyond SWBOffsetMax)
	for i := 50; i < 100; i++ {
		if lSpec[i] != 10.0 {
			t.Errorf("lSpec[%d] = %v, want 10.0 (beyond SWBOffsetMax)", i, lSpec[i])
		}
		if rSpec[i] != 2.0 {
			t.Errorf("rSpec[%d] = %v, want 2.0 (beyond SWBOffsetMax)", i, rSpec[i])
		}
	}
}
```

**Step 2: Run test to verify it passes**

Run: `make test PKG=./internal/spectrum`
Expected: PASS

**Step 3: Commit**

```bash
git add internal/spectrum/ms_test.go
git commit -m "$(cat <<'EOF'
test(spectrum): add SWBOffsetMax clamping test for MSDecode

Verify that SFB bounds are properly clamped to SWBOffsetMax,
preventing out-of-bounds access for short frames.

 Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
EOF
)"
```

---

## Task 9: Add Edge Case Tests

**Files:**
- Modify: `internal/spectrum/ms_test.go`

**Step 1: Write edge case tests**

Add to `internal/spectrum/ms_test.go`:

```go
func TestMSDecode_EmptyMaxSFB(t *testing.T) {
	// MaxSFB = 0 means no bands to process
	icsL := &syntax.ICStream{
		NumWindowGroups: 1,
		MaxSFB:          0,
		MSMaskPresent:   2,
	}
	icsL.WindowGroupLength[0] = 1
	icsL.SWBOffsetMax = 1024

	icsR := &syntax.ICStream{
		NumWindowGroups: 1,
		MaxSFB:          0,
	}
	icsR.WindowGroupLength[0] = 1

	lSpec := []float64{10.0, 20.0}
	rSpec := []float64{2.0, 4.0}

	cfg := &MSDecodeConfig{
		ICSL:        icsL,
		ICSR:        icsR,
		FrameLength: 1024,
	}

	MSDecode(lSpec, rSpec, cfg)

	// Should be unchanged
	if lSpec[0] != 10.0 || lSpec[1] != 20.0 {
		t.Errorf("lSpec modified when MaxSFB=0")
	}
	if rSpec[0] != 2.0 || rSpec[1] != 4.0 {
		t.Errorf("rSpec modified when MaxSFB=0")
	}
}

func TestMSDecode_NegativeValues(t *testing.T) {
	// Test with negative spectral values
	icsL := &syntax.ICStream{
		NumWindowGroups: 1,
		MaxSFB:          1,
		NumSWB:          1,
		MSMaskPresent:   2,
		WindowSequence:  syntax.OnlyLongSequence,
	}
	icsL.WindowGroupLength[0] = 1
	icsL.SWBOffset[0] = 0
	icsL.SWBOffset[1] = 4
	icsL.SWBOffsetMax = 1024
	icsL.SFBCB[0][0] = 1

	icsR := &syntax.ICStream{
		NumWindowGroups: 1,
		MaxSFB:          1,
		NumSWB:          1,
		WindowSequence:  syntax.OnlyLongSequence,
	}
	icsR.WindowGroupLength[0] = 1
	icsR.SWBOffset[0] = 0
	icsR.SWBOffset[1] = 4
	icsR.SFBCB[0][0] = 1

	// M = -10, S = 3
	// L = M + S = -7
	// R = M - S = -13
	lSpec := []float64{-10.0, -10.0, -10.0, -10.0}
	rSpec := []float64{3.0, 3.0, 3.0, 3.0}

	cfg := &MSDecodeConfig{
		ICSL:        icsL,
		ICSR:        icsR,
		FrameLength: 1024,
	}

	MSDecode(lSpec, rSpec, cfg)

	for i := 0; i < 4; i++ {
		if lSpec[i] != -7.0 {
			t.Errorf("lSpec[%d] = %v, want -7.0", i, lSpec[i])
		}
		if rSpec[i] != -13.0 {
			t.Errorf("rSpec[%d] = %v, want -13.0", i, rSpec[i])
		}
	}
}
```

**Step 2: Run tests to verify they pass**

Run: `make test PKG=./internal/spectrum`
Expected: PASS

**Step 3: Commit**

```bash
git add internal/spectrum/ms_test.go
git commit -m "$(cat <<'EOF'
test(spectrum): add edge case tests for MSDecode

Add tests for empty MaxSFB and negative spectral values.

 Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
EOF
)"
```

---

## Task 10: Run Full Test Suite and Lint

**Step 1: Run full test suite**

Run: `make check`
Expected: All tests pass, no lint errors

**Step 2: Commit if any formatting changes**

```bash
git add -A
git status
# If changes:
git commit -m "$(cat <<'EOF'
style: apply formatting from make check

 Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
EOF
)"
```

---

## Summary

**Files created:**
- `internal/spectrum/ms.go` - M/S stereo decoder (~50 lines)
- `internal/spectrum/ms_test.go` - Comprehensive tests (~250 lines)

**Files modified:**
- `internal/spectrum/helpers.go` - Added IsIntensityICS, IsNoiseICS
- `internal/spectrum/helpers_test.go` - Tests for new helpers

**Total estimated lines:** ~80 implementation + ~300 tests

**Key implementation notes:**
1. M/S transform is `L = M + S`, `R = M - S` (FAAD2 stores `tmp = L - R` then `L = L + R`, `R = tmp`)
2. Uses left channel's ICS for `ms_mask_present` and `ms_used`
3. Checks right channel's ICS for intensity stereo exclusion
4. Checks left channel's ICS for noise band exclusion
5. Properly handles window groups and short blocks via `nshort` offset
