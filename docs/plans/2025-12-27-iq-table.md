# Inverse Quantization Table Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Create the inverse quantization lookup table used to convert quantized spectral coefficients back to floating-point values.

**Architecture:** Generate a 8192-entry float64 table where `iq_table[i] = i^(4/3)`. The generator script uses Go's math.Pow to compute values. We validate against FAAD2's table by extracting reference values and comparing within floating-point tolerance.

**Tech Stack:** Pure Go, uses `math.Pow`, `go:generate` directive for regeneration.

---

## Background: FAAD2 Inverse Quantization

From `~/dev/faad2/libfaad/iq_table.h`:
- Table size: 8192 entries (IQ_TABLE_SIZE)
- Formula: `iq_table[i] = i^(4/3)` for i in 0..8191
- Type: `real_t` (float64 in non-fixed-point builds)
- Used by: `iquant()` in specrec.c for dequantization

The inverse quantization formula in AAC is:
```
spec[i] = sign(quant[i]) * iq_table[|quant[i]|]
```

Where `iq_table[x] = x^(4/3)` allows efficient lookup instead of computing the power each time.

---

## Task 1: Write Table Validation Test First

**Files:**
- Create: `internal/tables/iq_table_test.go`

### Step 1.1: Write failing test for table existence and size

```go
// internal/tables/iq_table_test.go
package tables

import "testing"

func TestIQTable_Size(t *testing.T) {
	if len(IQTable) != IQTableSize {
		t.Errorf("IQTable size: got %d, want %d", len(IQTable), IQTableSize)
	}
}

func TestIQTable_FirstValues(t *testing.T) {
	// Known values from FAAD2's iq_table.h
	expected := []float64{
		0,
		1,
		2.5198420997897464,
		4.3267487109222245,
		6.3496042078727974,
		8.5498797333834844,
		10.902723556992836,
		13.390518279406722,
		15.999999999999998,
		18.720754407467133,
	}

	for i, want := range expected {
		got := IQTable[i]
		if got != want {
			t.Errorf("IQTable[%d]: got %v, want %v", i, got, want)
		}
	}
}
```

### Step 1.2: Run test to verify it fails

Run: `go test -v ./internal/tables -run TestIQTable`
Expected: FAIL with "undefined: IQTable"

### Step 1.3: Commit failing test

```bash
git add internal/tables/iq_table_test.go
git commit -m "test(tables): add failing tests for IQ table"
```

---

## Task 2: Create IQ Table Constants

**Files:**
- Create: `internal/tables/iq_table.go`

### Step 2.1: Add IQ table size constant

```go
// internal/tables/iq_table.go
package tables

// IQTableSize is the number of entries in the inverse quantization table.
// Ported from: IQ_TABLE_SIZE in ~/dev/faad2/libfaad/iq_table.h:44
const IQTableSize = 8192

// IQTable contains precomputed values of i^(4/3) for i in 0..8191.
// Used for inverse quantization: spec[i] = sign(quant[i]) * IQTable[|quant[i]|]
//
// Ported from: iq_table in ~/dev/faad2/libfaad/iq_table.h:51
// Generated by: go generate ./internal/tables
var IQTable [IQTableSize]float64
```

### Step 2.2: Run test to verify it still fails (no values)

Run: `go test -v ./internal/tables -run TestIQTable`
Expected: FAIL - values are zero, not matching expected

### Step 2.3: Commit constant definition

```bash
git add internal/tables/iq_table.go
git commit -m "feat(tables): add IQ table constant and empty array"
```

---

## Task 3: Create Table Generator Script

**Files:**
- Create: `internal/tables/generate_iq_table.go`

### Step 3.1: Write the generator script

```go
//go:build ignore

// internal/tables/generate_iq_table.go
// Generator for inverse quantization table.
// Run with: go run generate_iq_table.go
package main

import (
	"fmt"
	"math"
	"os"
	"time"
)

const (
	iqTableSize = 8192
	outputFile  = "iq_table_data.go"
)

func main() {
	f, err := os.Create(outputFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "error creating file: %v\n", err)
		os.Exit(1)
	}
	defer f.Close()

	fmt.Fprintf(f, "// Code generated by generate_iq_table.go; DO NOT EDIT.\n")
	fmt.Fprintf(f, "// Generated at: %s\n", time.Now().Format(time.RFC3339))
	fmt.Fprintf(f, "//\n")
	fmt.Fprintf(f, "// Inverse quantization table: IQTable[i] = i^(4/3)\n")
	fmt.Fprintf(f, "// Ported from: ~/dev/faad2/libfaad/iq_table.h\n\n")
	fmt.Fprintf(f, "package tables\n\n")
	fmt.Fprintf(f, "func init() {\n")
	fmt.Fprintf(f, "\tiqTableData := [IQTableSize]float64{\n")

	for i := 0; i < iqTableSize; i++ {
		val := math.Pow(float64(i), 4.0/3.0)
		if i%4 == 0 {
			fmt.Fprintf(f, "\t\t")
		}
		fmt.Fprintf(f, "%.17g, ", val)
		if i%4 == 3 {
			fmt.Fprintf(f, "// %d-%d\n", i-3, i)
		}
	}
	fmt.Fprintf(f, "\t}\n")
	fmt.Fprintf(f, "\tcopy(IQTable[:], iqTableData[:])\n")
	fmt.Fprintf(f, "}\n")

	fmt.Printf("Generated %s with %d entries\n", outputFile, iqTableSize)
}
```

### Step 3.2: Run generator to create data file

Run: `cd /home/laurent/dev/go-aac/internal/tables && go run generate_iq_table.go`
Expected: Creates `iq_table_data.go` with all 8192 values

### Step 3.3: Verify the generated file exists

Run: `head -30 /home/laurent/dev/go-aac/internal/tables/iq_table_data.go`
Expected: See generated header and first values

### Step 3.4: Run tests to verify values match

Run: `go test -v ./internal/tables -run TestIQTable`
Expected: PASS - values now match FAAD2 reference

### Step 3.5: Commit generator and generated data

```bash
git add internal/tables/generate_iq_table.go internal/tables/iq_table_data.go
git commit -m "feat(tables): add IQ table generator and data"
```

---

## Task 4: Add go:generate Directive

**Files:**
- Modify: `internal/tables/iq_table.go`

### Step 4.1: Add go:generate comment

Update `internal/tables/iq_table.go` to add the generate directive at the top:

```go
// internal/tables/iq_table.go
package tables

//go:generate go run generate_iq_table.go

// IQTableSize is the number of entries in the inverse quantization table.
// Ported from: IQ_TABLE_SIZE in ~/dev/faad2/libfaad/iq_table.h:44
const IQTableSize = 8192

// IQTable contains precomputed values of i^(4/3) for i in 0..8191.
// Used for inverse quantization: spec[i] = sign(quant[i]) * IQTable[|quant[i]|]
//
// Ported from: iq_table in ~/dev/faad2/libfaad/iq_table.h:51
// Generated by: go generate ./internal/tables
var IQTable [IQTableSize]float64
```

### Step 4.2: Verify go generate works

Run: `cd /home/laurent/dev/go-aac && go generate ./internal/tables`
Expected: Regenerates `iq_table_data.go`

### Step 4.3: Run tests again

Run: `go test -v ./internal/tables -run TestIQTable`
Expected: PASS

### Step 4.4: Commit

```bash
git add internal/tables/iq_table.go
git commit -m "feat(tables): add go:generate directive for IQ table"
```

---

## Task 5: Comprehensive FAAD2 Validation Test

**Files:**
- Modify: `internal/tables/iq_table_test.go`

### Step 5.1: Add validation test against more FAAD2 values

Add to `internal/tables/iq_table_test.go`:

```go
func TestIQTable_FAAD2Reference(t *testing.T) {
	// Reference values extracted from ~/dev/faad2/libfaad/iq_table.h
	// Testing key indices across the table
	tests := []struct {
		index int
		value float64
	}{
		{0, 0},
		{1, 1},
		{2, 2.5198420997897464},
		{8, 15.999999999999998},
		{16, 40.317473596635935},
		{64, 256},
		{100, 464.15888336127773},
		{256, 1625.4986687073816},
		{512, 4096},
		{1000, 10000},
		{1024, 10321.273251814638},
		{2048, 26008.091396074065},
		{4096, 65536},
		{8191, 165113.4940829452}, // Last entry
	}

	for _, tc := range tests {
		got := IQTable[tc.index]
		// Allow small floating-point tolerance
		if !floatEquals(got, tc.value, 1e-10) {
			t.Errorf("IQTable[%d]: got %.17g, want %.17g", tc.index, got, tc.value)
		}
	}
}

func floatEquals(a, b, epsilon float64) bool {
	if a == b {
		return true
	}
	diff := a - b
	if diff < 0 {
		diff = -diff
	}
	return diff < epsilon
}

func TestIQTable_Formula(t *testing.T) {
	// Verify the mathematical formula is correct: IQTable[i] = i^(4/3)
	import "math"

	for i := 0; i < 100; i++ {
		expected := math.Pow(float64(i), 4.0/3.0)
		got := IQTable[i]
		if got != expected {
			t.Errorf("IQTable[%d]: got %.17g, want %.17g", i, got, expected)
		}
	}
}
```

### Step 5.2: Run comprehensive validation

Run: `go test -v ./internal/tables -run TestIQTable`
Expected: All PASS

### Step 5.3: Commit

```bash
git add internal/tables/iq_table_test.go
git commit -m "test(tables): add comprehensive IQ table FAAD2 validation"
```

---

## Task 6: Add Lookup Function

**Files:**
- Modify: `internal/tables/iq_table.go`
- Modify: `internal/tables/iq_table_test.go`

### Step 6.1: Write failing test for lookup function

Add to `internal/tables/iq_table_test.go`:

```go
func TestIQuant(t *testing.T) {
	tests := []struct {
		name     string
		input    int16
		expected float64
		hasError bool
	}{
		{"zero", 0, 0, false},
		{"positive_1", 1, 1, false},
		{"positive_8", 8, 15.999999999999998, false},
		{"negative_1", -1, -1, false},
		{"negative_8", -8, -15.999999999999998, false},
		{"positive_max", 8191, 165113.4940829452, false},
		{"negative_max", -8191, -165113.4940829452, false},
		{"overflow_positive", 8192, 0, true},
		{"overflow_negative", -8192, 0, true},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			got, err := IQuant(tc.input)
			if tc.hasError {
				if err == nil {
					t.Error("expected error, got nil")
				}
			} else {
				if err != nil {
					t.Errorf("unexpected error: %v", err)
				}
				if got != tc.expected {
					t.Errorf("got %v, want %v", got, tc.expected)
				}
			}
		})
	}
}
```

### Step 6.2: Run test to verify it fails

Run: `go test -v ./internal/tables -run TestIQuant`
Expected: FAIL with "undefined: IQuant"

### Step 6.3: Implement IQuant function

Add to `internal/tables/iq_table.go`:

```go
import "errors"

// ErrIQTableOverflow indicates the quantized value exceeds table bounds.
var ErrIQTableOverflow = errors.New("tables: inverse quantization value out of range")

// IQuant performs inverse quantization: returns sign(q) * |q|^(4/3).
// Uses the precomputed IQTable for efficiency.
//
// Returns error if |q| >= IQTableSize (8192).
//
// Ported from: iquant() in ~/dev/faad2/libfaad/specrec.c:430-497
func IQuant(q int16) (float64, error) {
	if q < 0 {
		if -q >= IQTableSize {
			return 0, ErrIQTableOverflow
		}
		return -IQTable[-q], nil
	}
	if q >= IQTableSize {
		return 0, ErrIQTableOverflow
	}
	return IQTable[q], nil
}
```

### Step 6.4: Run test to verify it passes

Run: `go test -v ./internal/tables -run TestIQuant`
Expected: PASS

### Step 6.5: Commit

```bash
git add internal/tables/iq_table.go internal/tables/iq_table_test.go
git commit -m "feat(tables): add IQuant inverse quantization function"
```

---

## Task 7: Add Pow2SF Table (Bonus - commonly used with IQ)

**Files:**
- Modify: `internal/tables/iq_table.go`
- Modify: `internal/tables/iq_table_test.go`

### Step 7.1: Write failing test for Pow2SF table

Add to `internal/tables/iq_table_test.go`:

```go
func TestPow2SFTable_Size(t *testing.T) {
	// pow2sf_tab in specrec.c has 64 entries
	if len(Pow2SFTable) != 64 {
		t.Errorf("Pow2SFTable size: got %d, want 64", len(Pow2SFTable))
	}
}

func TestPow2SFTable_Values(t *testing.T) {
	// Values from ~/dev/faad2/libfaad/specrec.c:501-523
	expected := []float64{
		2.9802322387695313E-008, 5.9604644775390625E-008, 1.1920928955078125E-007,
		2.384185791015625E-007, 4.76837158203125E-007, 9.5367431640625E-007,
	}
	for i, want := range expected {
		got := Pow2SFTable[i]
		if !floatEquals(got, want, 1e-20) {
			t.Errorf("Pow2SFTable[%d]: got %.17g, want %.17g", i, got, want)
		}
	}
}
```

### Step 7.2: Run test to verify it fails

Run: `go test -v ./internal/tables -run TestPow2SFTable`
Expected: FAIL with "undefined: Pow2SFTable"

### Step 7.3: Add Pow2SFTable constant

Add to `internal/tables/iq_table.go`:

```go
// Pow2SFTable contains precomputed 2^((i-25)/4) values for scale factor application.
// Index 25 = 1.0, smaller indices give smaller values, larger give larger values.
//
// Used for: spec[i] *= Pow2SFTable[sf + offset]
//
// Ported from: pow2sf_tab in ~/dev/faad2/libfaad/specrec.c:501-523
var Pow2SFTable = [64]float64{
	2.9802322387695313E-008, 5.9604644775390625E-008, 1.1920928955078125E-007,
	2.384185791015625E-007, 4.76837158203125E-007, 9.5367431640625E-007,
	1.9073486328125E-006, 3.814697265625E-006, 7.62939453125E-006,
	1.52587890625E-005, 3.0517578125E-005, 6.103515625E-005,
	0.0001220703125, 0.000244140625, 0.00048828125,
	0.0009765625, 0.001953125, 0.00390625,
	0.0078125, 0.015625, 0.03125,
	0.0625, 0.125, 0.25,
	0.5, 1.0, 2.0,
	4.0, 8.0, 16.0, 32.0,
	64.0, 128.0, 256.0,
	512.0, 1024.0, 2048.0,
	4096.0, 8192.0, 16384.0,
	32768.0, 65536.0, 131072.0,
	262144.0, 524288.0, 1048576.0,
	2097152.0, 4194304.0, 8388608.0,
	16777216.0, 33554432.0, 67108864.0,
	134217728.0, 268435456.0, 536870912.0,
	1073741824.0, 2147483648.0, 4294967296.0,
	8589934592.0, 17179869184.0, 34359738368.0,
	68719476736.0, 137438953472.0, 274877906944.0,
}
```

### Step 7.4: Run test to verify it passes

Run: `go test -v ./internal/tables -run TestPow2SFTable`
Expected: PASS

### Step 7.5: Commit

```bash
git add internal/tables/iq_table.go internal/tables/iq_table_test.go
git commit -m "feat(tables): add Pow2SFTable for scale factor application"
```

---

## Task 8: Run Full Test Suite and Lint

**Files:**
- All modified files

### Step 8.1: Run format and lint

Run: `make fmt && make lint`
Expected: No errors or warnings

### Step 8.2: Fix any import issues

If math import is missing in test file, add it:

```go
import (
	"math"
	"testing"
)
```

### Step 8.3: Run all tests

Run: `make test`
Expected: All tests PASS

### Step 8.4: Run full project check

Run: `make check`
Expected: PASS

### Step 8.5: Final commit if any cleanup

```bash
git add -A
git commit -m "chore(tables): clean up and ensure lint passes"
```

---

## Summary

This plan implements Step 2.3: Inverse Quantization Table:

| File | Purpose | Lines |
|------|---------|-------|
| `internal/tables/iq_table.go` | Constants, IQuant function, Pow2SFTable | ~80 |
| `internal/tables/iq_table_test.go` | Validation tests | ~100 |
| `internal/tables/generate_iq_table.go` | Generator script | ~50 |
| `internal/tables/iq_table_data.go` | Generated table data (8192 entries) | ~2100 |

**Key components:**
- `IQTable[8192]float64` - precomputed `i^(4/3)` values
- `IQuant(q int16)` - lookup with sign handling
- `Pow2SFTable[64]float64` - scale factor multipliers
- `go generate` support for regeneration

**Validation:**
- First 10 values match FAAD2 exactly
- Key indices across table verified
- Formula `i^(4/3)` verified programmatically
